"""Contains a tool that guarantees every name in the project will be unique.

This class is intended to be used primarily for signals (VHDL) and wires/
registers (Verilog). It can also be useful for ports, variables, and modules;
however, you should think about the ramifications of doing so. Additionally,
Verilog does not support variables for synthesis, whereas in VHDL variables
can be used for synthesis but the wisdom in doing so is complicated. Therefore,
using variables for synthesis is not recommended if the end design must work
in both Verilog and VHDL."""
from validate_lang import comment_start
from eol import eol


class CentralNameGen:
    """Important: Create ONE instance of this object in your highest level Python
    module, and pass that instance into every object.

    There are both pros and cons to guaranteeing unique port names. Give some
    thought to whether you really want:

        my_output_port_n000001 => some_signal_n432998,
        ...
        my_output_port_n999999 => some_other_signal_n264310

    It is indispensable for some situations, but if the number of outputs
    changes, and ports are inherently different things, regret may be engendered.

    This module is most likely to be useful when you have a large number of
    the same thing, but they are just time delayed versions of each other.

    The number field starts with 'n', which simply stands for "number".
    For example:
        signal      some_name_n000001 : std_logic_vector(7 downto 0);
        signal      some_other_name_n000002 : std_logic_vector(15 downto 0);
    Making the number field start with _n makes it easier to machine-parse
    names generated by this class.

    When generating a name, you can optionally include the delay_num keyword.
    Its purpose is to include the time delay relative to some datum, such as
    an input in some entity. This can be useful if you want to document the
    latency (in clock cycles) that some signal will change values relative
    to an input port in some entity. This field, if it exists, starts with
    'd'."""
    def __init__(self, **kwargs):
        self.num = 0
        if "num_digits" in kwargs:
            self.format_str = "%0"
            self.format_str += str(kwargs["num_digits"])
            self.format_str += "d"
            self.num_digits = kwargs["num_digits"]
        else:
            self.format_str = "%04d"
            self.num_digits = 4
        self.short_comments = {}
        self.long_comments = {}

        if "max_comment_len" in kwargs:
            self.max_comment_len = kwargs["max_comment_len"]
        else:
            self.max_comment_len = 32

        if "column_width" in kwargs:
            self.column_width = kwargs["column_width"]
        else:
            self.column_width = 80

        self.documentation_filename = "./documentation.txt"
        # Erase anything in the documentation file:
        with open(self.documentation_filename, 'w') as f:
            f.write("")

    def get_one_name(self, name_stub, *args, **kwargs):
        self.num += 1

        # Guarantee that the resulting number field will fit in the allotted number of digits:
        assert(len("%d" % self.num) <= self.num_digits)

        one_name = name_stub + "_n" + (self.format_str % self.num)

        if "delay_num" in kwargs:
            one_name += "_d" + (self.format_str % kwargs["delay_num"])

        if "name_type" in kwargs:
            if kwargs["name_type"] == "signal":
                one_name += "_s"
            elif kwargs["name_type"] == "input":
                one_name += "_i"
            elif kwargs["name_type"] == "output":
                one_name += "_o"
            elif kwargs["name_type"] == "module":
                one_name += "_m"
            elif kwargs["name_type"] == "variable":
                one_name += "_v"
            else:
                raise ValueError("Unrecognized name_type")

        if "short_comment" in kwargs:
            assert(len(kwargs["short_comment"]) <= self.max_comment_len)
            self.short_comments[self.num] = kwargs["short_comment"]

        if "docstring" in kwargs:
            self.long_comments[self.num] = \
                self.make_docstring_tag(self.num) + kwargs["docstring"]
            if self.num not in self.short_comments.keys():
                self.short_comments[self.num] = ""
            self.short_comments[self.num] += self.make_docstring_tag(self.num)

        return one_name

    def add_documentation(self, n, docstr):
        if n not in self.long_comments.keys():
            self.long_comments[n] = ''
        self.long_comments[n] += docstr + eol

    def make_docstring_tag(self, n):
        """Generates a tag that allows short, inline comments to be associated
        with verbose documentation in a separate file."""
        return "<docstring=" + (self.format_str % n) + ">"

    def render_short_comments(self, target_lang, which_key):
        return comment_start(target_lang) + self.short_comments[which_key]

    def render_documentation(self):
        """Call this once after all components have been added to design."""
        y = []
        for i in self.long_comments.keys():
            y.append(eol)
            y.append(self.make_docstring_tag(i))
            y.append(self.long_comments[i])
        with open(self.documentation_filename, 'a') as f:
            for i in self.long_comments.keys():
                f.write(self.long_comments[i])
                f.write(eol)


if __name__ == "__main__":
    uut = CentralNameGen()
    for m in range(10):
        print(uut.get_one_name(name_stub="whatever_signal"))
    for m in range(10):
        print(uut.get_one_name(name_stub="some_other_signal"))

    uut = CentralNameGen(num_digits=8)
    uut.num = 99462384
    for m in range(10):
        print(uut.get_one_name(name_stub="some_sig", delay_num=889472))
    print(uut.get_one_name(name_stub="pwm", name_type="module"))
    print(uut.get_one_name(name_stub="pwm", name_type="input"))
    print(uut.get_one_name(name_stub="pwm", name_type="output"))
    print(uut.get_one_name(name_stub="pwm", name_type="signal"))

    try:
        # Verify we catch an unrecognized name type:
        print(uut.get_one_name(name_stub="pwm", name_type="garbage"))
    except ValueError as e:
        assert(str(e) == "Unrecognized name_type")
        print("Successfully caught an unrecognized name type")

    try:
        # Verify we catch an excessive number of calls:
        uut.num = 1E20
        print(uut.get_one_name(name_stub="pwm"))
    except AssertionError as e:
        print("Successfully caught a really high number")
